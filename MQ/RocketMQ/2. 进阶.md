## 如何保证消息的可用性/可靠性/不丢失
![[Pasted image 20240404223546.png]]
### 生产阶段
**通过请求确认机制，保证消息的可靠传递**
1. 同步发送：通过响应结果保证消息的可靠传递
2. 异步发送：在回调方法中检查发送失败或异常
3. 如果发送超时，通过查询日志的API，来检查是否在Broker存储成功

### 存储阶段
**通过配置可靠性优先的Broker参数来避免因为宕机丢消息**
1. 只要消息持久化到CommitLog中，即使Broker宕机，未消费的消息也能重新恢复再消费。
2. Broker的刷盘机制：同步刷盘和异步刷盘
3. Broker通过主从模式保证高可用
![[Pasted image 20240404225356.png]]
### 消费阶段
**再业务逻辑执行完成后返回消息确认**

## 如何处理消息重复的问题
1. 业务幂等：多次调用和一次调用的效果是一样的
2. 消息去重：对重复的消息不再消费(数据库去重表)

## 消息积压
![[Pasted image 20240404230856.png]]
1. 消费者扩容：Message Queue > 消费者数量
2. 消息迁移Queue扩容：Message Queue <= 消费者数量
![[Pasted image 20240404231117.png]]

## 顺序消息如何实现
### 部分顺序消息
生产者将消息发送到同一个Message Queue，消费过程中从同一个Message Queue读取的消息顺序处理，并且消费者不能并发处理顺序消息。
![[Pasted image 20240404231423.png]]
### 全局顺序消息
![[Pasted image 20240404231904.png]]
简单来说，为了保证整个 Topic全局消息有序，只能消除所有的并发处理，各部分都设置成单线程处理 ，这时候就完全牺牲RocketMQ的高并发、高吞吐的特性了。

## 如何实现消息过滤
**两种方案：**
1. Broker端按照Consumer的去重逻辑进行过滤
2. 在Consumer端过滤

**Consumer端过滤三种方法：**
1. 根据Tag过滤
2. SQL表达式过滤
3. Filter Server过滤

## 延时消息
RocektMQ支持的延迟级别：
``` java
private String messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h";
```

实现原理：
临时存储 + 定时任务
![[Pasted image 20240404234643.jpg]]

Broker收到延时消息了，会先发送到主题（SCHEDULE_TOPIC_XXXX）的相应时间段的Message Queue中，然后通过一个定时任务轮询这些队列，到期后，把消息投递到目标Topic的队列中，然后消费者就可以正常消费这些消息。

## 如何实现分布式消息事务？半消息？
![[Pasted image 20240404235446.png]]

## 死信队列
死信消息的特点：
1. 不会被消费者正常消费
2. 有效期与正常消息相同

死信队列的特点：
1. 死信队列对应一个GroupID，不是对应单个消费者实例
2. 如果一个GroupID未产生死信消息，消息队列RocketMQ不会为其创建对应的死信队列
3. 一个死信队列包含了对应GroupID产生的多有死信消息，无论属于哪个Topic。

## 如何保证RocketMQ的高可用
**RocketMQ的高可用主要体现在Broker的读和写的高可用，Broker的高可用是通过集群和主从实现的。**
![[Pasted image 20240405001140.png]]
读请求可以自动从Master切换到Slave，对于写请求，要手动将Slave转成Master。