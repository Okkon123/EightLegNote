## 解释执行和编译执行的区别
**解释执行：** 程序运行时，将源代码逐行转换为机器码，然后执行
**编译执行：** 程序运行前，将源代码一次性转换为机器码，然后执行

Java代码在执行前，先将源代码编译成字节码，运行时由JVM解释器逐行将字节码转换为机器码执行。

JVM会将热点代码编译后放入CodeCache，下次执行时，会从CodeCache中直接读取机器码然后执行。
![[Pasted image 20240409135854.png]]

## 类的生命周期
![[Pasted image 20240409135915.png]]
## 类的加载过程
### 载入
1. 通过类的全限定名获取字节流
2. 将字节流的静态存储结构转换为方法区运行时数据结构
3. 在内存中生成类的java.lang.Class对象，作为方法区访问类的数据的访问入口
![[Pasted image 20240409152323.png]]
### 验证
对二进制字节流进行校验，符合JVM规范的才能被JVM正确执行。

### 准备
对静态变量分配内存并且初始化，变量被赋为默认值。

### 解析
虚拟机将常量池内的符号引用替换为直接引用。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型。

### 初始化
准备阶段对类变量赋初值，初始化阶段将代码赋为代码期望的之。

## 类加载器的种类
1. Bootstrap ClassLoader(启动类加载器)
2. Extensions ClassLoarder(扩展类加载器)
3. System ClassLoarder(系统类加载器)
4. User ClassLoarder(用户自定义加载器)

## 双亲委派机制
![[Pasted image 20240409153209.png]]
当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。所有的类加载器都会被传送到最顶层的启动类加载器。只有当父加载器无法完成这个类加载请求时，子加载器才会尝试自己去完成加载。

## 为什么要用双亲委派机制
**保证应用程序的稳定有序**

## 如何破坏双亲委派机制

**破坏双亲委派机制：**
重写loadClass()

**不打破双亲委派机制：**
重写ClassLoader类的fifindClass()方法，无法被父类加载的类最终会被这个方法被加载。

## 历史上有几次双亲委派机制的破坏
![[Pasted image 20240409154316.png]]
### 第一次破坏

### 第二次破坏

### 第三次破坏


## 怎么实现一个热部署功能
1. 销毁原来的自定义ClassLoader
2. 更新class类文件
3. 创建新的 ClassLoader 去加载更新后的 class 类文件。

## Tomcat的类加载机制
![[Pasted image 20240409155220.png]]将不同应用之间的类区分开，防止冲突。