## JVM的内存区域
![[Pasted image 20240407224414.png]]
线程共享：
1. 方法区
2. 堆
线程私有：
1. 虚拟机栈
2. 本地方法栈
3. 程序计数器

### 虚拟机栈
![[Pasted image 20240407224618.png]]
### 本地方法栈
与虚拟机栈类似，本地方法栈为虚拟机所用到的本地方法服务。

### Java堆
![[Pasted image 20240407224853.png]]
被所有线程共享，在虚拟机启动时创建。
几乎所有对象都在堆中分配。
Java堆是垃圾收集器所管理的内存区域。
![[Pasted image 20240407225021.png]]
### 方法区
方法区被各个线程共享，用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存。
JDK1.7时，方法去被永久代替代，JDK1.8永久代被彻底移除，被元空间替代。


## JDK1.6 1.7 1.8 内存区域的变化
JDK1.6 使用永久代实现方法区：
![[Pasted image 20240407225635.png]]

JDK1.7 将字符串常量池、静态变量存放在堆上
![[Pasted image 20240407225707.png]]
JDK1.8 取消永久代，在内存空间直接内存区域划出一块作为元空间
![[Pasted image 20240407225811.png]]
## 为什么使用元空间替代永久代

客观上：
使用永久代实现方法区更容易导致Java更容易遇到内存溢出的问题。

主观上：
历史原因

## 对象的创建过程
![[Pasted image 20240407230221.png]]
1. 检查指令的参数是否能在常量池中定位到一个类的符号引用
2. 检查符号应用的类是否被加载过，如果没有则加载
3. 类加载后，为新生对象分配内存
4. 内存分配完成后，将分配的内存空间(不包括对象头)初始化为0
5. 设置对象头

## 指针碰撞 空闲列表
内存分配方式：
**指针碰撞：** 假设Java堆内存规整，分界点一边全部被分配，一边全部未分配。内存分配时将分界移动分配距离。
**空闲列表：** Java堆内存不规整，空闲和已使用内存交错在一起，分配时选择一块足够大的空间分配，更新列表。
分配方式由Java堆是否规整决定，Java堆是否规整由垃圾处理器是否有整理能力决定。
![[Pasted image 20240407231103.png]]

## JVM 里new对象时，堆会发生抢占吗？JVM怎么保证线程安全
会发生抢占
解决方法：
1. CAS，采用CAS重试保证原子性
2. TLAB，预先为每个线程在堆中分配一块内存，本地缓冲区耗尽，分配新的缓冲区锁定。
![[Pasted image 20240407231541.png]]

## 对象的内存布局
![[Pasted image 20240407231551.png]]

### 为什么要进行8字节对齐
CPU进行内存访问时，一次寻址的指针大小是8字节，不内存对其会出现跨缓存行访问。
![[Pasted image 20240407231911.png]]
### Object a = new Object()的大小
![[Pasted image 20240407232029.png]]
### 对象引用的大小
![[Pasted image 20240407232245.png]]
## 对象怎么访问定位
![[Pasted image 20240407233335.png]]
![[Pasted image 20240407233354.png]]
句柄优势：reference存储的是句柄地址，对象移动时只要改变句柄的实例数据指针，reference不需要修改。
直接指针修饰：一次可访问到对象，速度快。
HotSpot使用直接指针。

## 内存溢出和内存泄漏
内存泄漏：申请的空间没有正确释放，内存白白占用
内u才能溢出：申请的内存超过了可用内存

## 常见内存溢出情况
1. Java堆溢出
2. Java栈溢出

## 内存泄漏常见原因
![[Pasted image 20240407235514.png]]
1. 静态集合类，静态集合生命周期和JVM一致，静态集合引用的对象不能被释放。
2. 单例模式，单例对象在初始化后会以静态变量的方式在JVM整个生命周期中存在。
3. 数据连接、IO、Socket，创建的连接不close无法被GC回收
4. 变量不合理的作用域
5. hash值发生改变
6. ThreadLocal使用不当

## 如何判断对象仍然存活
1. 引用计数算法
2. 可达性分析算法
![[Pasted image 20240408000407.png]]

## Java中GC Roots的种类

GC Roots种类：
1. 虚拟机栈中的引用
2. 本地方法栈中JNI的引用
3. 类静态变量
4. 运行时常量池中的变量
![[Pasted image 20240408004247.png]]

## 对象有几种引用
1. 强引用
2. 软引用
3. 弱引用
4. 虚引用
![[Pasted image 20240408010152.png]]
## finalize()方法
GC前标记筛选，筛选条件为是否有必要执行finalize()方法，如果在finalize()中拯救自己，就不会被回收。

## Java堆内存分区
![[Pasted image 20240408010542.png]]

## 垃圾回收算法
1. 标记-清除算法
![[Pasted image 20240408010620.png]]
2. 标记-复制算法
![[Pasted image 20240408010642.png]]
3. 标记整理算法
![[Pasted image 20240408010656.png]]
## 新生代的区域划分
![[Pasted image 20240408010727.png]]
## Minor GC/Young GC、Major GC/Old GC、Full GC
**Partial GC(部分收集)：** 不是完整收集整个Java堆的垃圾收集 
1. Minor GC/Young GC(新生代收集)
2. Major GC/Old GC(老年代收集)
3. Mixed GC(混合收集)
**Full GC(整堆收集)：** 收集整个Jav堆和方法区

## Minor GC / Young GC 什么时候触发
新创建对象优先在新生代Eden区进行分配，如果Eden区没有足够的空间时，就会触发Young GC来清理新生代。

## 什么时候会触发Full GC
![[Pasted image 20240408011257.png]]

## 对象什么时候会进入老年代
![[Pasted image 20240408101134.png]]
1. 长期存活的对象会进入老年代，在YoungGC 15次后，对象会被移入老年代。
	-XX：maxTenuringRhreshold 可以通过这个参数改变上限次数
2. 大对象直接进入老年代
	-XX：PretenureSizeThreshold
3. 动态对象年龄判断
4. 空间分配担保

## 有哪些垃圾收集器
**垃圾收集器分类：**
1. 分代收集器 CMS
2. 分区收集器 G1、ZGC

### Serial
单线程，工作时需要暂停其他所有线程，Stop the World
![[Pasted image 20240408102558.png]]
### ParNew
Serial的多线程并行版本
![[Pasted image 20240408102705.png]]
### Parallel Scavenge
基于标记复制算法，与ParNew类似，但更关注垃圾收集的吞吐量
![[Pasted image 20240408102959.png]]
### Serial Old
Serial Old 是 Serial 收集器的老年代版本
### Parallel Old
Parallel Old 是 Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法
![[Pasted image 20240408145451.png]]
### CMS
以获取最短回收停顿时间为目标，采用”标记-清除算法“，分四大布进行垃圾收集，初始标记和重新标记会STW。
![[Pasted image 20240408150937.png]]
### Garbage First
G1 再JDK9 取代了CMS成为了默认的垃圾收集器。G1 有五个属性：分代、增量、并行、标记整理、STW。
![[Pasted image 20240408151059.png]]

### ZGC (?)
目标是再不超过10ms的停顿时间内，为堆大小达到16TB的应用提供高吞吐量的垃圾收集器。
![[Pasted image 20240408151637.png]]

### 垃圾回收器的作用
核心作用：自动管理Java应用程序的运行时内存，识别哪些内存不再被应用程序使用，并释放这些内存以便重新使用。
减少了程序员手动管理内存的负担，降低了内存泄漏和溢出的风险。

## Stop The World、OopMap、安全点

**STW(Stop The World)：** 为了确保对象引用更新的正确性，暂停所有的用户线程。
**OooMap：** 数据结构映射表，记录对象内什么偏移量上是什么类型的数据。
**安全点：** 用户执行到安全点才能暂停。
安全点的常见位置：
1. 循环的末尾
2. 方法临返回前 / 调用方法的call指令后
3. 可能抛异常的位置


## CMS收集器的垃圾收集过程
1. 初始标记 STW
2. 并发标记
3. 重新标记 STW
4. 并发标记
![[Pasted image 20240408172301.png]]
## G1 垃圾收集器
![[Pasted image 20240408172925.png]]
1. 初始标记 STW
2. 并发标记
3. 最终标记 STW
4. 筛选回收 STW
![[Pasted image 20240408173027.png]]

## 为什么有了CMS还要有G1
**CMS优点：** 
1. 并发收集，低停顿
**CMS缺点：** 
1. 标记清理导致内存碎片比较多
2. 并发标记时抢占用户线程的资源
3. 并发清除阶段会产生浮动垃圾，只能下次gc

## 线上用的是什么垃圾收集器？为什么使用
JDK1.8 默认使用**Parallel Scavenge + Parallel Old**，新生代使用Parallel Scavenge收集器，老年代Parallel Old收集器。

Parallel Scavenge特点：
高吞吐

Parallel New + CMS:
关注服务器响应速度，采用CMS降低停顿时间。
## 垃圾收集器怎么选择
1. Serial：应用内存空间小，没有停顿时间要求的单线程处理器。
2. Parallel：有峰值性能的考虑，没有时间要求，能够容忍1秒或更长的停顿时间。
3. CMS/G1：响应时间比吞吐量优先级高，垃圾收集暂停时间要保持在1秒以内
4. ZGC：响应时间高优先级，堆空间比较大
## 对象一定分配在堆中吗？逃逸分析
**对象不一定分配在堆中。**

**方法逃逸：** 当对象被new出来时，被外部所调用，或者作为参数传递到外部。
**线程逃逸：** 作为对象被外部线程访问到，例如赋值给其他线程中的实例变量。
![[Pasted image 20240408174622.png]]

![[Pasted image 20240408174630.png]]
**逃逸分析的优点：**
1. 栈上分配
2. 同步消除
3. 标量替换