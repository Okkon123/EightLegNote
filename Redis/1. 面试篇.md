## 认识Redis
### Redis与Memcached异同
共同点：
1. 基于内存的数据库
2. 都有过期策略
3. 两者的性能都很高
不同点：
1. Redis的数据类型更加丰富
2. Redis支持数据的持久化
3. Redis原生支持集群模式
4. Redis支持发布订阅、Lua脚本、事务
### 为什么使用Redis作为MySQL缓存
1. Redis具备高性能
2. Redis具备高并发

## Redis数据结构
### Redis数据类型
1. String
2. List
3. Set
4. Hash
5. Zset
6. BitMap
7. HyperLogLog
8. GEO
9. Stream

### 五种常见Redis数据类型如何实现？
![[9fa26a74965efbf0f56b707a03bb9b7f.webp]]

## Redis线程模型
### Redis不是单线程的
**核心模块是单线程的。**
Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的

![[后台线程.webp]]
### Redis单线程模式
![[redis单线程模型.drawio.webp]]
### Redis单线程为什么快
1. Redis操作大部分在内存中完成
2. Redis单线程模型避免了多线程竞争
3. Redis采用I/O复用机制处理大量的客户端Socket请求

### Redis6.0 之前为什么使用单线程
CPU不是制约Redis性能表现的瓶颈，更多的时受到内存大小和网络I/O的限制。多线程增加了系统复杂度，存在线程切换、加锁解锁、死锁造成的新能损耗。

### Redis6.0 之后为什么引入多线程
Redis性能瓶颈出现在网络I/O的处理上。Redis6.0对于网络I/O采用多线程来处理，对于命令的执行，Redis依然使用单线程处理。Redis6.0引入的多线程I/O对新能提升了一倍以上。

## Redis持久化
### Redis如何实现数据不丢失
1. AOF日志
2. RDB快照
3. 混合持久化方式

### AOF日志如何实现
AOF：将命令追加到文件中

#### AOF写回策略
1. Always
2. Everysec
3. No
![[98987d9417b2bab43087f45fc959d32a-20230309232253633.webp]]
AOF文件过大会启用AOF重写机制，来压缩AOF文件。
#### AOF重写日志
重写AOF日志过程由后台子进程bgrewriteof完成。
当子进程进行bgrewriteof时，主进程主要进行三个工作。
1. 执行客户端发来的命令
2. 将执行后的写命令追加到AOF缓冲区
3. 将执行后的写命令追加到AOF重写缓冲区
子进程完成重写工作后，主进程发送一条信号调用信号处理函数：
1. 将AOF重写缓冲区中的内容追加到新的AOF文件
2. 对新的AOF改名，覆盖现有的AOF文件。

### RDB快照如何实现
RDB快照记录某一个瞬间的内存数据。
RDB是全量快照，基于COW技术，可以通过配置改变bgsave频率。

### RDB为什么有混合持久化
1. RDB数据恢复速度快，快照频率不好确认。
2. AOF丢失数据少，数据回复不快。

混合持久化：前半部分是RDB格式的全量数据，后半部分是AOF的增量数据。
![[f67379b60d151262753fec3b817b8617-20230309232312657.webp]]

混合持久化优点：
更快的启动，降低了数据丢失的风险。

混合持久化缺点：
1. AOF文件中添加了RDB的内容，AOF可读性变差。
2. 兼容性差，开启混合持久化，此AOF文件不能用在Redis4.0之前版本。

## Redis集群
### Redis如何实现服务高可用
1. 主从复制
2. 哨兵模式
3. 切边集群模式
![[2b7231b6aabb9a9a2e2390ab3a280b2d.webp]]
![[26f88373d8454682b9e0c1d4fd1611b4.webp]]
![[redis切片集群映射分布关系.webp]]
切边集群：
一个切片集群有16384个哈希槽。
哈希槽分配方式：
1. 平均分配
2. 手动分配

### 脑裂导致数据丢失怎么办
当主节点发现节点下线或通行潮湿的数量大于阈值时，禁止主节点进行写数据。
1. min-slaves-to-write x，主节点必须要x个从节点连接，否则禁止主节点写数据。
2. min-slaves-max-lag x, 主从复制和同步的延迟不能超过x秒。否则禁止主节点写数据。

## Redis过期删除与过期淘汰
### Redis使用的过期删除策略
**惰性删除 + 定期删除**
![[惰性删除 1.webp]]

惰性删除优点：占用系统资源少
惰性删除缺点：不能及时删除数据，造成内存浪费

### 定期删除策略
每隔一段时间随机从数据库中取出一定数量key检查，删除其中过期key。
![[定时删除流程 1.webp]]
定期删除优点：通过限制删除操作的时长和频率减少删除操作对CPU影响。减少了过期键对空间的无效占用。
定期删除缺点：操作的时长和频率难以缺点。
### Redis持久化时，过期键如何处理
1. RDB：
	1. RDB生成阶段：对key进行过期检查，过期键不会保存在RDB文件中。
	2. RDB加载阶段：主服务器载入RDB文件不会将过期键载入到数据库中。从服务器将所有键载入数据库。
2. AOF：
	1. AOF写入阶段：过期键会被保存，当此过期键被删除后，Redis会向AOF追加DEL命令。
	2. AOF重写阶段：过期键不会被保存到重写后的AOF文件中。

### Redis主从模式对过期键如何处理
从库不会过期扫描，主库在key到期时在AOF文件增加DEL指令，同步到所有从库。

### Redis内存满了会发生扫描
触发内存淘汰机制。

### Redis内存淘汰策略
1. noeviction
2. volatile-random
3. volatile-ttl
4. volatile-lru
5. volatile-lfu
6. allkeys-random
7. allkeys-lru
8. allkeys-lfu

### LRU 和 LFU 
LRU：最近最少使用，根据时间淘汰
Redis实现近似LRU算法，在Redis对象结构体中添加一个额外字段，记录数据的最后一次访问时间。
LFU：最近最不常用，根据访问次数淘汰

**在 LRU 算法中**，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。

**在 LFU 算法中**，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)，用来记录 key 的访问频次。

## Redis 缓存设计
### 如何避免缓存雪崩、缓存击穿、缓存穿透
缓存雪崩：
1. 将缓存失效时间随机打散
2. 逻辑过期
缓存击穿：
1. 互斥锁
2. 逻辑过期
缓存穿透：
1. 布隆过滤器
2. 缓存空对象
3. 互斥锁

### 如何设计一个缓存策略，动态更新热点数据
通过数据最新访问时间来做排名，并过滤掉不长访问的数据，只留下经常访问的数据。

### 常见的缓存更新策略
1. Cache Aside
	1. 读策略：如果缓存有，直接返回。若缓存无，读取数据库数据，将数据写到缓存。
	2. 写策略：先更新数据库，在删除缓存中的数据。
		**Cache Aside 适合读多写少的场景，不适合写多的场景**
2. Read/Write Through
	1. 读策略
	2. 写策略
![[WriteThrough.webp]]
3. Write Back
Write Back问题：数据不是强一致的，有数据丢失的风险。

### 如何保证缓存和数据库数据一致
1. 先删除数据库，再删除缓存
	**如何保证两个操作都执行成功**
	1. 消息队列重试
	2. 订阅MySQL binlog(canal)，再操作缓存
2. 先删除缓存，再操作数据库
	1. 延迟双删


## Redis实战
### Redis如何实现延迟队列
![[延迟队列.webp]]
### Redis的大Key如何处理
**什么是大Key：**
1. String类型值大于10KB
2. Hash、List、Set、ZSet类型元素个数超过5000个
**大Key问题：**
1. 客户端超时阻塞
2. 引发网络阻塞
3. 阻塞工作线程
4. 内存分布不均
**如何找到大Key**
1. redis-cli --bigkeys
2. 使用SCAN查找大Key
3. 使用RdbTools工具查找大Key
**如何删除大Key**
1. 分批次删除
2. 异步删除
### Redis管道有什么用
管道技术可以解决多个命令执行时的网络等待。
### Redis事务支持回滚吗
Redis没有提供回滚机制。
Redis并不一定保证原子性。

Redis为什么不支持事务回滚：
1. 复杂的功能与Redis追求的简单高效的设计主旨不符合
2. Redis事务执行时错误由编程错误造成，通常出现在开发环境中，很少在实际生产环境中出现，没有必要实现事务回滚功能。
### 如何用Redis实现分布式锁
![[分布式锁.webp]]
Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁

Redis实现分布式锁优点：
1. 性能高效
2. 实现方便
3. 避免单点故障

Redis实现分布式锁缺点：
1. 超时时间不好设置
2. Redis主从复制模式中的数据时异步复制的，导致分布式锁的不可靠性。

#### Redis如何解决集群下分布式锁的可靠性：
**红锁：** 让客户端和多个独立的Redis节点依次申请加锁，如果客户端能够和半数以上的节点成功完成加锁操作，那么客户端成功获得分布式锁。

加锁成功条件：
1. 客户端从半数以上的Redis节点获得锁
2. 客户端从大多数系欸但获取锁的总耗时小于锁设置的过期时间。
