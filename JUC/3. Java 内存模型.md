## Java内存模型的理解
![[Pasted image 20240406130237.png]]
线程的共享变量存储在主内存，每一个线程都有一个私有的本地内存，本地内存存储了共享内存的副本。
当一个线程更改了本地内存共享变量的副本后，需要把更改刷新到主内存中，确保其他线程可以看到这些更改。
读取共享变量时，先从本地内存读取，若过期从主内存读取。

### 为什么线程要用自己的内存
1. 多线程直接操作主内存的共享变量会引发更多的内存竞争访问。
2. CPU会对指令重排序，使用本地内存可不影响最终执行结果的前提下，使得CPU有更大的自由度乱序执行指令。

## 原子性、可见性、有序性
原子性：一个操作是不可分割、不可中断的，要么全执行，要么全不执行
可见性：一个线程修改了共享变量的值，其他线程能够立即知道这个修改
有序性：一个线程的执行代码，从前往后依次执行

## 什么是指令重排
![[Pasted image 20240406131325.png]]
1. 编译器优化的重排序，编译器不改变原意的情况下重排序
2. 指令级并行的重排序，处理器将多条指令并行执行，改变执行顺序
3. 内存系统的重排序，处理器使用缓存和读写缓冲区，使得加载和存储看起来乱序执行。

## 指令重排有限制吗？happens-before
指令重排的限制：
1. happens-before
2. as-if-serial

happens-before：
1. 一个操作happens-before另一个操作，第一个操作的结果对第二个操作可见，第一个操作的执行顺序在第二个操作之前
2. 两个操作存在happens-before关系，只要重排序之后的执行结果和happens-before关系执行结果一致，那么重排序合法。

happens-before规则：
![[Pasted image 20240406132822.png]]
1. 程序顺序规则
2. 监视锁规则
3. volatile变量规则
4. 传递性
5. start() 规则
6. join() 规则

## as-if-serial是什么？单线程一定是顺序的吗？

as-if-serial：不管怎么重排序，**单线程的执行结果不能被改变**。编译器、runtime、处理器都必须遵守as-if-serial语义。

## volatile实现原理
volatile作用：
1. 可见性
2. 有序性

**对于声明为volatile的内存：**
写入变量时直接刷新回主内存，当读变量时，会从主内存重新获取值
![[Pasted image 20240406135203.png]]
**volatile如何保持有序性：**
![[Pasted image 20240406135237.png]]
![[Pasted image 20240406135323.png]]
![[Pasted image 20240406135330.png]]
1. 在volatile写操作的前面插入一个StoreStore屏障
2. 在volatile写操作的后面插入一个StoreLoad屏障
3. 在volatile读操作的后面插入一个LoadLoad屏障
4. 在volatile读操作的后面插入一个LoadStore屏障
