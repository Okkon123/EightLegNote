## 锁
### 锁的种类
#### 全局锁
**开启锁：**
flush tables with read lock
**释放锁:**
unlock tables
通过MVCC可实现对全表备份
#### 表级锁
1. **表锁**
	**加锁**
	lock tables t_student read
	lock tables t_student write
	**释放锁**
	unlock tables
	**表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作**
2. **元数据锁(MDL)**
	数据库操作时自动加上MDL，事务执行期间MDL是一直被持有的，MDL写锁优先级高于读锁，队列中的写锁会阻塞后来到达的读锁。
3. **意向锁**
	在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
	在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；
	**意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（_lock tables ... read_）和独占表锁（_lock tables ... write_）发生冲突。**
	**意向锁的目的是为了快速判断表里是否有记录被加锁**
4. **AUTO-INC**
	AUTO-INC锁实现主键自增，性能较低，后可使用轻量级锁实现主键自增。
#### 行级锁
![[x锁和s锁.webp]]
1. Record Lock 记录锁
2. Gap Lock 间隙锁
3. Next-Key Lock 临键锁
4. 插入意向锁 

### MySQL是怎么加锁的
#### 什么样的SQL语句会加锁
1. 锁定读(select ... lock in share mode / select ... for update)
2. update
3. delete

#### MySQL是怎么加行级锁的？
**加锁的对象是索引，加锁的基本单位是 next-key lock**，它是由记录锁和间隙锁组合而成的，**next-key lock 是前开后闭区间，而间隙锁是前开后开区间**。
##### 唯一索引等值查询
1. 当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会**退化成「记录锁」**。
2. 当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会**退化成「间隙锁」**。
###### 记录存在的情况
``` MySQL
mysql> select * from user where id = 1 for update;
```
![[唯一索引记录锁.drawio.webp]]
###### 记录不存在的情况

``` MySQL
mysql> select * from user where id = 2 for update;
```
![[唯一索引间隙锁.drawio.webp]]
##### 唯一索引范围查询
1. 情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会**退化成记录锁**。
2. 情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：
    - 当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，**扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁**，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。
    - 当条件值的记录在表中，如果是「小于」条件的范围查询，**扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁**，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。
###### 「大于或者大于等于」的范围查询

``` MySQL
mysql> select * from user where id > 15 for update;
```
![[唯一索引范围查询大于15.drawio.webp]]
``` MySQL
mysql> select * from user where id >= 15 for update;
```
![[唯一索引范围查询大于等于15.drawio.webp]]
###### 针对「小于或者小于等于」的范围查询
``` MySQL
mysql> select * from user where id < 6 for update;
```
![[唯一索引范围查询小于等于6.drawio.webp]]
``` MySQL
mysql> select * from user where id <= 5 for update;
```
![[唯一索引范围查询小于等于5.drawio 1.webp]]
``` MySQL
select * from user where id < 5 for update;
```
![[唯一索引范围查询小于5.drawio.webp]]

##### 非唯一索引等值查询
**因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁**。

1. 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是**非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁**。
2. 当查询的记录「不存在」时，**扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁**。

###### 记录不存在的情况
``` MySQL
mysql> select * from user where age = 25 for update;
```
![[非唯一索引等值查询age=25.drawio.webp]]

当有一个事务持有二级索引的间隙锁 (22, 39) 时，什么情况下，可以让其他事务的插入 age = 22 或者 age = 39 记录的语句成功？
**当有一个事务持有二级索引的间隙锁 (22, 39) 时，插入 age = 22 或者 age = 39 记录的语句是否可以执行成功，关键还要考虑插入记录的主键值，因为「二级索引值（age列）+主键值（id列）」才可以确定插入的位置，确定了插入位置后，就要看插入的位置的下一条记录是否有间隙锁，如果有间隙锁，就会发生阻塞，如果没有间隙锁，则可以插入成功**。
###### 记录存在的情况
``` MySQL
mysql> select * from user where age = 22 for update;
```
![[非唯一索引等值查询存在.drawio.webp]]

##### 非唯一索引范围查询
**非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况**
``` MySQL
mysql> select * from user where age >= 22  for update;
```
![[非唯一索引范围查询age大于等于22.drawio.webp]]
##### 没有加索引的查询
如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。
**在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了**
![[唯一索引加锁流程.webp]]
![[非唯一索引加锁流程.webp]]

### update没加索引会锁全表
对当前读、update、delete语句，没有使用索引时，会走全表扫描，对全表加上next-key锁，将全表锁住。
**如何避免此类事故发生**
开启sql_safe_updates


### MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗
幻读的解决方案：
1. 对于快照读：通过MVCC方式解决了幻读
2. 对于当前读：通过next-key lock解决了幻读
**可重复读隔离级别下没能完全解决幻读**
### MySQL死锁了，怎么办
间隙锁和间隙锁之间是兼容的。
记录锁与间隙锁是不兼容的。
记录锁与记录锁间不兼容。

插入意向锁是一种特殊的间隙锁，但该锁只用于并发插入操作。
插入意向锁和间隙锁、next-key不共存。

#### Insert语句是怎么加行级锁的？
Insert语句正常执行时不会生成锁结构，靠聚簇索引自带的trx_id隐藏列来作为隐式锁保护记录。

**每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态**

隐式锁转换为显示锁情况：
1. 记录之间加有间隙锁
2. Insert记录和已有记录存在唯一键冲突
	1. 主键索引重复，插入新记录的事务给已存在的主键重复的聚簇索引添加S型记录锁
	2. 唯一耳机索引重复，插入新纪录的事务会给已存在的耳机索引列重复的二级索引添加S型next-key锁

### 如何避免死锁
死锁的四个必要条件：
1. 互斥
2. 占有且等待
3. 不可强占用
4. 循环等待

解决方案：
1. 设置事务等待锁的超时时间
2. 开启主动死锁检测