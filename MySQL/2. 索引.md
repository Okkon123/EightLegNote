## 索引
### 常见面试题
#### 索引的分类
**数据结构**
1. B+ Tree索引
2. Hash索引
3. Full-test索引
**物理存储**
1. 聚簇索引(主键索引)
2. 二级索引(辅助索引)
**字段特性**
1. 主键索引
2. 唯一索引
3. 普通索引
4. 前缀索引
**字段个数**
1. 单列索引
2. 联合索引

#### 什么时候需要创建索引

#### 优化索引的方法
1. 前缀索引优化
2. 覆盖索引优化
3. 主键自增
4. 放置索引失效
**索引执行效率：**
1. ALL
2. index
3. range
4. ref
5. eq_ref
6. const

### 数据存储
InnoDB按数据页为单位读写数据。
数据页结构：
![[fabd6dadd61a0aa342d7107213955a72.webp]]

![[557d17e05ce90f18591c2305871af665.webp]]
![[261011d237bec993821aa198b97ae8ce.webp]]

### 为什么MySQL使用B+树作为索引
**前提：访问磁盘的速度很慢**
需要一个查找速度快，增删查改速度快，每次访问总体的数据量小的数据结构。
**二分查找树**：极端情况退化成链表
**自平衡二叉树(红黑树)**：层数太高，导致磁盘IO操作次数过多。
**B树**：B树非叶子节点包含数据，每次会访问很多没用的数据，如果需要范围查询需要中序遍历，插入删除效率低。
**B+树**：层数低，非叶子节点只包含索引，范围查询方便，增加删除效率高

**MySQL单表不超过2000W行？**
数据越多，索引高度越高，导致IO增多，查询效率急剧下降。

### 索引失效情况
1. 对索引使用左或者左右模糊匹配
2. 对索引使用函数
3. 对索引进行表达式计算
4. 对索引隐式类型转换
5. 联合索引非最左匹配
6. Where子句中的OR
7. MySQL使用like ”%x"，索引不一定失效
### Count性能
![[af711033aa3423330d3a4bc6baeb9532.webp]]
count函数作用：统计符合查询条件的记录中，函数值指定的参数不为NULL的个数。
**count(\*) = count(0)**

**为什么要通过遍历的方式计数**
1. InnoDB引擎支持事务，不能简单的维护一个变量满足不同事物状况下计数的要求。
**如何优化count(*)**
1. 使用explain近似估算记录数
2. 额外维护计数值